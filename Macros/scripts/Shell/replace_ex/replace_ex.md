# Replace_EX — Replace in files

Replace_EX is a Far Manager macro (Lua) for searching and replacing text inside files. It supports plain and regular-expression searches, interactive confirmations, recursive folder processing, a "function mode" where the replacement is generated by Lua code, destination path redirection, and several other options.

This manual explains how to install, run and use the utility, describes all dialog options, and contains examples and troubleshooting tips.

---

## Requirements

- Far Manager (far2m/far3 compatible)
- The macro file: `replace_ex.lua` (located at Macros/scripts/Shell/replace_ex/replace_ex.lua in this repo)

Notes:
- The macro is defensive about binary data — it will skip files containing NULL bytes or invalid UTF-8.
- Files larger than 128 MiB will be skipped unless you explicitly choose to process them when prompted.

---

## Installation

1. Put `replace_ex.lua` into your Far macros folder at:
   `Macros/scripts/Shell/replace_ex/replace_ex.lua` (or the equivalent macros location for your installation).
2. Reload macros or restart Far Manager.
3. The macro defines a Shell-area macro with keybinding `Ctrl+Alt+E`. You may change the key if desired.

---

## Run / Entry points

- Run from Far's Shell area by pressing Ctrl+Alt+E (default).
- You may also run the Lua script directly (when not running as a Macro) — it will launch the dialog and perform the operation.

---

## What it does

- Searches files matched by a file mask (e.g. `*.txt`, `**/*.lua`) starting from the active panel directory.
- Optionally searches recursively.
- Replaces occurrences either by:
  - a string/templated replacement with support for escapes and group references, or
  - a Lua "function mode" replacement where you provide Lua code to produce the replacement.
- Optionally writes results into a destination path (keeping file relative paths) instead of overwriting originals.
- Interactively prompts for each replacement (Yes / Yes for file / Yes for all / Skip / Skip file / Cancel) with counters and an option to Abort operation.

---

## Dialog / Options (explanations)

When launched you get a dialog with the following controls:

- Recursively
  - Search files in subfolders if checked.

- File mask
  - File name filter (mask). Must be valid; invalid mask will show an error.

- Destination path (enable)
  - If enabled, the processed files will be written under the specified destination path preserving relative paths. When disabled, files are overwritten in-place.

- Search for
  - Text or regular expression to find. Must not be empty.

- Replace with
  - The replacement text or Lua code (when Function mode is enabled).

- Regular expressions
  - Enable regex mode. If unchecked, the search string is treated as literal (special characters are escaped).

- Case sensitive
  - If unchecked, search is case-insensitive.

- Whole words
  - Surrounds the search pattern with word boundary anchors so only whole words match.

- Ignore spaces (Extended)
  - When in regex mode, enables the extended flag (x) — whitespace in the pattern is ignored (except in character classes and escaped).

- Multi-line
  - When in regex mode, enables the multiline flag (m) — ^ and $ match line start/end.

- File as a line
  - When in regex mode, enables the single-line or DOTALL behavior (s) so '.' matches newline characters.

- Function mode
  - Enables "Function mode" where the Replace field contains Lua code which will be executed for each match to produce a replacement string (or to skip or stop).

- Initial code
  - Optional Lua code executed once before processing any files (used for setup).

- Final code
  - Optional Lua code executed once after processing all files (used for cleanup / summary).

Buttons:
- Run — start the operation.
- Clear — reset dialog controls to defaults.
- Reload — reload saved controls from settings.
- Save — save current dialog settings.
- Cancel — close dialog and do nothing.

---

## Replacement syntax (non-function mode)

When Function mode is NOT used:

- Backreferences: use `$1`, `$2`, ... or `${1}`, `${2}` to insert capture groups from the regex.
  - If regex mode is not enabled, the search is treated as literal and no capture groups exist.
- Escape sequences (in the Replace field) are processed:
  - Typical escapes are supported: `\n`, `\t`, `\r`, `\f`, `\a` (bell), and `\e` (escape, ASCII 27). Unknown `\x` become `x` (the backslash is dropped).
- Implementation notes:
  - Internally the tool parses the replacement and allows mixing literal parts and numeric group references.
  - If your replacement references a group number that does not exist in the pattern, an error is shown.

Examples:
- Replace "foo" with "bar": Search = `foo`, Replace = `bar` (plain mode).
- Swap two regex groups: Search (regex) = `(\w+)\s+(\w+)`, Replace = `$2 $1`
- Insert newline: Replace = `first line\nsecond line` (use `\n` escape).

---

## Function mode (advanced)

When Function mode is enabled, the Replace field is treated as a Lua chunk. For each match the macro will call your function to compute the replacement. This gives full programmability and access to per-file counters, global accumulators and file metadata.

What you can use in function mode:
- Your replace chunk is loaded as a Lua chunk and executed for each match, in a sandbox environment containing useful variables:
  - FN — current file full path (string)
  - M — current file match counter (incremented each time a match is encountered)
  - R — current file replacements (incremented each time a replacement is performed)
  - item — table with file metadata (the same object returned by the recursive search callback)
  - N1, N2 — numeric counters you can use (initialized to 0 before files processing begin)
  - n1, n2 — numeric counters you can use (initialized to 0 each file)
  - A1, A2 — tables you can use (initialized to {}  before files processing begin)
  - a1, a2 — tables you can use (initialized to {} each file)
- The replacement function receives the regex capture groups as positional arguments. Additionally a table `T` is made available so you can refer to captures as `T[0]` (full match) and `T[1]..T[n]` for the groups.
- You may return:
  - a string (or number) — the replacement to insert,
  - false/nil — skip this occurrence (no replacement),
  - any non-string non-number truthy value — interpreted as "stop further replacements in this file".

Initial / Final code:
- Initial code (`Initial code` edit) is executed once before processing files (useful to set global accumulators).
- Final code is executed once after all files are processed (e.g. print summary, write results).

Example function-mode workflow:

Initial code (InitFunc)
```lua
-- run once before processing
total_replacements = 0
```

Replace field (replace)
```lua
-- this code is evaluated for each match; captures are passed as arguments,
-- T[0] is the full match, T[1]..T[n] are capture groups
total_replacements = total_replacements + 1
R = R + 1     -- R is per-file replacements counter available in the env
return "[" .. tostring(T[0]) .. "]"
```

Final code (FinalFunc)
```lua
-- run once after processing
far.Message("Total replacements: " .. tostring(total_replacements), "Replace_EX")
```

Notes and safety:
- If your replacement returns a non-string non-number truthy value, that value will stop further replacements in the current file.
- If your replacement returns false or nil, that occurrence is skipped (no replacement).
- Lua errors in your code will be reported and the operation will abort for the current file.

---

## Interactive prompts and options

During processing the macro may prompt you when:
- A file is larger than the configured MAX_SIZE (default 128 MiB). You may Skip, Process anyway, or Terminate.
- A replacement is found (unless you previously chose Yes for this file or Yes for all) — you are shown a dialog with:
  - Yes (replace now)
  - Yes for this file (automatically replace further occurrences in this file)
  - Yes for all files (automatically replace all further occurrences everywhere)
  - Skip
  - Skip for this file
  - Cancel (terminate the entire operation)
- If an error occurs while opening file for read/write, you get an option to Continue or Terminate.

Escaping / Aborting:
- The tool periodically checks for the Escape key. If Escape is pressed you will be asked if you want to break the operation. If you confirm, processing stops and no additional files are processed.

---

## Behavior & Safety

- Binary or invalid UTF-8 files are skipped by design.
- If writing to destination fails, you are prompted to Continue or Terminate. Original files are not deleted by this macro — it writes (overwrites) target files directly.
- The macro first collects the list of files to process (a pre-scan) to avoid picking up files created by the macro while it runs.
- Statistics: At the end you will get a summary with the number of processed files and number modified.

---

## Limitations

- Files larger than 128 MiB are skipped by default (prompted).
- Non-UTF-8 files are not processed (they are skipped).
- The replace pattern parsing supports common escapes and numeric backreferences of the form `$n` and `${n}`. If you rely on more complex replacement template features, consider using Function mode.
- The implementation is tied to the regex engine available in this Far/Lua environment — behavior for advanced regex features depends on that engine.

---

## Examples

1) Simple literal replace in current folder (non-recursive):
- File mask: `*.txt`
- Search for: `foo`
- Replace with: `bar`
- Regular expressions: unchecked
- Run

2) Regex replace across files (recursive):
- Recursively: on
- File mask: `**/*.md` or `*.md` depending on your Far version mask rules
- Regular expressions: on
- Search for: `(\b)(TODO)(\b)`
- Replace with: `[$2]` or, equivalently, function mode can be used
- Note: `$1`, `$2` correspond to capture groups.

3) Use Function mode to increment numbers found in text:
- Regular expressions: on
- Function mode: on
- Search for: `(\d+)`
- Replace (example function)
```lua
-- replace field
local n = tonumber(T[1]) or 0
n = n + 1
return tostring(n)
```

4) Use a destination path (do not overwrite originals):
- Enable Destination path and set it to `C:\temp\out` — the macro will create directories as necessary and write processed files there.

---

## Troubleshooting

- "Empty search string" — the Search for field cannot be empty.
- "Invalid group number" — your replacement references a group (e.g. `$3`) that isn't present in the pattern.
- "File is too large" — you can choose to skip or process anyway when prompted; consider using a different tool for huge files.
- If the macro silently skips files: check that they are valid text files with no NUL bytes and valid UTF-8.

---

## Internals & advanced notes (for power users)

- The macro forces the regex search to be wrapped in an extra capturing group when regex mode is used. This makes the whole match available consistently among the capture arguments passed to replacement logic.
- The replace parser supports `\` escapes and `$n`/`${n}` backreferences. Escapes like `\n` and `\t` are converted to their control characters.
- In function mode the environment (`setfenv`) contains:
  - per-run counters and tables (`N1`, `N2`, `A1`, `A2`)
  - per-file counters and tables (`n1`, `n2`, `a1`, `a2`)
  - `FN`, `M`, `R` and `item` for file context
  - `T` table with captures (T[0] = full match, T[1..] = groups) — you can also access captures as the function arguments.
- The macro checks for Escape key periodically (configured delta 0.2 sec) and prompts for abort to allow the user to stop long operations.

---
