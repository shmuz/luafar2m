<header>
tag=SMZ1
ver=2.7
</header>
<node>
id=1
lv=0
dt=Text
nm=LuaFAR for Editor (version 2.8)
mtime=3851705231
<article>
#_<markdown>
#_**LuaFAR for Editor** (a FAR plugin) is a collection of utilities
#_that implement various actions controlling the work of FAR's
#_Editor. The plugin also allows to add the unlimited number of new
#_utilities. Both the plugin and the utilities are written in Lua
#_programming language. 
#_
#_For description of the built-in utilities and the Configuration
#_Dialog, see the plugin's help file.
#_
#_- [User's utilities](8.html)
#_- [Command line](59.html)
#_- [Plugin API](31.html)
#_- [Lua Modules](21.html)
#_- [Credits](10.html)
#_
#_
</article>
</node>
<node>
id=8
lv=0
dt=Text
nm=User's utilities
<article>
#_<markdown>
#_
#_### Installing user's utilities
#_
#_Installing user's utilities can be done via the file **_usermenu.lua**
#_lying in the plugin's directory. This file is run in two cases:
#_
#_- When FAR calls `SetStartupInfo` of the plugin
#_- When the command "Reload User File" from the Configuration Menu
#_  is executed
#_
#_There are a few [installation functions](36.html) that are
#_intended to be called from **_usermenu.lua**.
#_
#_### Running user's utilities
#_
#_User utilities can be run in the following ways:
#_
#_- Via a menu item; see [`AddToMenu`](13.html).
#_- Via a shortcut (from Editor only), see [`AddToMenu`](13.html).
#_- From the [command line](59.html) (the plugin registers a command
#_  line prefix **`lfe`**); see [`AddCommand`](57.html).
#_
#_### Running scripts without installation
#_
#_- From the Editor: use the included utility *Lua Script*.
#_- From the [command line](59.html).
#_
#_### Links
#_
#_[Installation functions](36.html)<br>
#_[Packets of scripts](37.html)<br>
#_[Binary modules](38.html)<br>
#_[Example of use](14.html)<br>
#_
#_
#_
</article>
</node>
<node>
id=36
lv=1
dt=Text
nm=Installation functions
mtime=3852664569
<article>
#_<markdown>
#_
#_[`AddToMenu`](13.html)<br>
#_[`AddCommand`](57.html)<br>
#_[`AddEvent`](20.html)<br>
#_[`AddUserFile`](34.html)<br>
#_[`AutoInstall`](35.html)<br>
#_
</article>
</node>
<node>
id=13
lv=2
dt=Text
nm=AddToMenu
mtime=3852463666
<article>
#_<markdown>
#_**`AddToMenu (where, text, hotkey, handler [, ...])`**
#_
#_Function `AddToMenu` is available to the *_usermenu.lua* script.<br>
#_It allows to add a specified utility to the plugin's menu and
#_assign it a hot key.
#_
#_### Parameters
#_
#_1. `where`<br>
#_Where the utility is intended to run from: any combination
#_of letters **[cdepv]** (**c**=configuration menu, **d**=dialog, **e**=editor, **p**=panels, **v**=viewer).
#_
#_1. `text`<br>
#_Text that should appear in the menu.<br>
#_-- To assign a hot key without adding a menu item, supply a `nil`.<br>
#_-- To add a separator, specify a string beginning with `":sep:"`
#_   following by optional text, e.g. `":sep:Block commands"`.<br>
#_-- If the [utility for localization](68.html) is used, and `text`
#_   begins with `"::"`, then the rest of the text is treated as a
#_   message identifier. (In the case of separator, prefix `":sep:::"`
#_   can be used).
#_
#_1. `hotkey`<br>
#_A key combination for calling the utility, e.g. `"Alt+Shift+F4"`.<br>
#_Supply `nil` if no hot key is needed.<br>
#_**NOTE:** a hot key assigned this way works **only from Editor**,
#_provided that no macro is assigned to that key.
#_
#_1. `handler`<br>
#_  -- Either name of a Lua script file to run upon this item activation
#_(its path is relative to the plugin's directory), or<br>
#_  -- a Lua function, or<br>
#_  -- the number of a built-in utility (1 to 6).
#_
#_1. Extra parameters (optional)<br>
#_Values that will be passed to user script (they are passed to the
#_script in a table). There can be any number of values of any Lua
#_type.
#_
#_### Examples
#_
#_      AddToMenu ("e", "Count words", nil, "countw.lua")
#_      AddToMenu ("e", "Count letters", "Alt+F2", "countl.lua")
#_      AddToMenu ("e", "Search", "Ctrl+F", "search.lua", "search")
#_      AddToMenu ("p", "Rename Files", nil, "rename.lua")
#_      AddToMenu ("evp", "Calendar", "Alt+F12", "calendar.lua", "show")
#_
#_To assign a hot key to a built-in utility, supply `text` as `nil`
#_and specify the number of the built-in utility via `handler`:
#_      AddToMenu ("e", nil, "Ctrl+1", 1)
#_
</article>
</node>
<node>
id=57
lv=2
dt=Text
nm=AddCommand
mtime=3852046562
<article>
#_<markdown>
#_**`AddCommand (command, handler [, ...])`**
#_
#_Function `AddCommand` is available to the *_usermenu.lua* script.<br>
#_It establishes a correspondence between the given `command` and
#_the specified action (`handler`). This allows to run that action
#_either from the command line or from a macro.
#_
#_### Parameters
#_
#_1. `command`<br>
#_The first command line parameter after the plugin's prefix.
#_
#_1. `handler`<br>
#_Either name of a Lua script file (its path is relative to the plugin's directory),
#_or a Lua function.
#_
#_1. Extra parameters (optional)<br>
#_Values that will be passed to the handler (they are passed in a table).
#_There can be any number of values of any Lua type.
#_
#_### Note
#_
#_If the command line contains arguments that follow the command then those
#_arguments will be passed on to the handler.
#_
#_### Examples
#_      AddCommand("calc", "scripts/calc.lua")
#_      AddCommand("hello", function() far.Message("Hello") end)
#_
</article>
</node>
<node>
id=20
lv=2
dt=Text
nm=AddEvent
mtime=3852664455
<article>
#_<markdown>
#_**`AddEvent (event_name, handler)`**
#_
#_Function `AddEvent` is available to the *_usermenu.lua* script.<br>
#_It allows to add a function handler that will be further called on some FAR event.
#_
#_`event_name` can be one of the following strings:
#_
#_* `"EditorInput"`
#_* `"EditorEvent"`
#_* `"ViewerEvent"`
#_* `"ExitScript"`
#_
#_### Notes about the handlers
#_
#_1. There can be multiple handlers for the same event type. They will
#_   be called in the order their files are specified in
#_   `_usermenu.lua`.
#_1. The handlers' input parameters correspond to the *exported
#_   functions* with the same names, e.g. `ViewerEvent`
#_   corresponds to `export.ProcessViewerEvent`, etc. (see LuaFAR manual
#_   for details). `ExitScript` has no parameters, no return value.
#_1. If the return value of a handler's `EditorInput` is true,
#_   the rest of `EditorInput` handlers are not called, and
#_   true is returned to Far.
#_1. The return values of `EditorEvent` and `ViewerEvent` handlers
#_   are ignored.
#_1. `EditorInput` handlers are not called when a user-defined
#_   hot key is pressed.
#_1. `ExitScript` is called when the plugin is about to be unloaded.
#_   It is also called before the "Reload User file" operation.
#_
</article>
</node>
<node>
id=34
lv=2
dt=Text
nm=AddUserFile
mtime=3491216844
<article>
#_<markdown>
#_**`AddUserFile (filename)`**
#_
#_Function `AddUserFile` is available to the *_usermenu.lua* script.
#_
#_Parameter `filename` (its path is relative to the plugin's directory)
#_specifies a file that is treated as an additional *_usermenu.lua* file.
#_
#_All utilities added by [`AddToMenu`](13.html) and
#_[`AddCommand`](57.html) calls within the file specified by `filename`
#_share a common environment that does not change until the next
#_*Reload User File* operation (or until FAR termination).
#_
#_In fact, the plugin itself executes `AddUserFile("_usermenu.lua")`.
#_
#_
</article>
</node>
<node>
id=35
lv=2
dt=Text
nm=AutoInstall
mtime=3491216961
<article>
#_<markdown>
#_**`AutoInstall (startpath, [filepattern], [depth])`**
#_
#_Function `AutoInstall` is available to the *_usermenu.lua* script.<br>
#_It looks for files whose names match `filepattern` in the directory
#_given by `startpath` and its subdirectories recursively,
#_and calls [`AddUserFile`](34.html) for each matching file found.
#_
#_### Parameters
#_
#_1. `startpath` (string)<br>
#_A path relative to the plugin's directory
#_
#_1. `filepattern` (string, or nil)<br>
#_Lua regular expression specifying what files to install.
#_Only file name (without path) is matched against this regular
#_expression. If the parameter is not specified, the value
#_`"^_usermenu%.lua$"` is used.
#_
#_1. `depth` (number, or nil)<br>
#_The maximum depth of subdirectories to recurse into.
#_When it is 0, the search is conducted only in `startpath`.
#_When it is not specified, the recursion depth is unlimited.
#_
#_### Warning
#_This function should be used with caution since it runs
#_every matching file found.
#_
#_### Examples
#_
#_      AutoInstall ("scripts")
#_      AutoInstall ("scripts", nil, 1)
#_      AutoInstall ("scripts/cool", "^_.*menu%.lua$", 0)
#_
</article>
</node>
<node>
id=73
lv=1
dt=Text
nm=Input data of installed scripts
ctime=3491725586
mtime=3491811735
<article>
#_<markdown>
#_An installed script, when it is run conventionally, always receives a single argument of *table* type.
#_
#_### Scripts installed via `AddToMenu` call (run from plugin menu or shortcut)
#_
#_* The array part of the table contains the additional arguments specified in the `AddToMenu` call.
#_* The hash part of the table has the field **`From`** that contains either of the following strings: **"config"**, **"dialog"**, **"editor"**, **"panels"** or **"viewer"**.
#_* In the case `From=="dialog"`, the table also has the field **`hDlg`**, that contains the dialog handle (a userdata value).
#_
#_### Scripts installed via `AddCommand` call (run via plugin command)
#_
#_* The array part of the table contains the additional arguments specified in the `AddCommand` call followed by the command line arguments.
#_* The hash part of the table has the field **`From`** that contains the string **"panels"**.
#_
</article>
</node>
<node>
id=37
lv=1
dt=Text
nm=Packets of scripts
<article>
#_<markdown>
#_If there is a set of utilities that is distributed as a single
#_unit ("packet of scripts"), it makes sense to install it separately
#_from other scripts.
#_
#_* The standard location for adding packets of scripts is
#_**`<plugin_path>/scripts`**.
#_It is recommended to install the packet in subdirectory
#_**`<plugin_path>/scripts/<packet_name>`**.
#_
#_* The plugin modifies `package.path` by adding at the beginning:
#_**`<plugin_path>/scripts/?.lua;`**. (So the user doesn't have to.)
#_
#_* Due to the danger of module names collision, it is **not** recommended
#_for packet writers to further modify `package.path`. Instead, start
#_the argument of every `require` call with `<packet_name>`.
#_E.g., if the packet is named *fl_scripts* then do:
#_`require 'fl_scripts/utils/read_config'`
</article>
</node>
<node>
id=68
lv=1
dt=Text
nm=Utility for localization
ctime=3485729339
mtime=3486625193
<article>
#_<markdown>
#_
#_The plugin contains a utility for adding localization to user packets of scripts. The utility consists of two files:
#_<plugin_directory>/**`lf4ed_lang.lua`** and **`far2/makelang.lua`**.
#_
#_(1) Create a "language template" file (similar to **`lf4ed_lang.templ`** file in the plugin directory), let's assume it is *scripts/my_package/lang.templ*.
#_
#_   * The exact syntax of "language template" files is described in the file **`far2/makelang.lua`**. The template file should be in UTF-8 encoding, with or without BOM.
#_
#_   * Choose some prefix for all your message identifiers (e.g. "mp"), to avoid conflicts with the existing message identifiers (if conflicts occur, they are detected by the program).
#_
#_   * Every script using this message system should **`require "lf4ed_message"`**. This returns a table that can be accessed for retrieving localized messages.
#_
#_(2) Run the following command from the plugin's directory:<br>
#_        lua lf4ed_lang.lua scripts/my_package/lang.templ
#_If no errors occured, this will extend **`*.lng`** files and **`lf4ed_message.lua`** file with the localized messages of your script package.
#_
#_(3) Restart Far.
#_
#_
#_**Example of use:**
#_        local M = require "lf4ed_message"
#_        ........
#_        far.Message(M.mpSomeMsgText, M.mpSomeMsgTitle, M.mpSomeMsgButtons)
#_
#_
</article>
</node>
<node>
id=38
lv=1
dt=Text
nm=Binary modules
<article>
#_<markdown>
#_
#_Sometimes, user scripts may need some binary module (e.g.,
#_*LuaFileSystem*) for its functioning. There are two ways
#_of installing the binary modules:
#_
#_* If there is no specific setup for changing `package.cpath`
#_  (usually via the environment variable `LUA_CPATH`), then
#_  put the binary modules into `%FARHOME%` directory.
#_
#_* Otherwise, put the binary modules into any directory listed
#_  in `package.cpath`.
#_
#_
</article>
</node>
<node>
id=14
lv=1
dt=Text
nm=Example of use
mtime=3852664803
<article>
#_<markdown>
#_### _usermenu.lua
#_    AddToMenu("e", "Count words", nil, "countw.lua")
#_    AddToMenu("e", "Count letters", "Alt+F2", "countl.lua")
#_    AddToMenu("evp", "Calendar", "Alt+F12", "calendar.lua", "show")
#_    AddToMenu("c", "Calendar", nil, "calendar.lua", "config")
#_    AddCommand("calen", "calendar.lua", "show")
#_    AddUserFile("scripts/fl_scripts/_usermenu.lua")
#_    AddUserFile("scripts/Rh_Scripts/_testmenu.lua")
#_    AddUserFile("handlers.lua")
#_
#_### handlers.lua
#_    local F = far.Flags
#_
#_    local function ReplaceChar (Rec)
#_      if (Rec.EventType == F.FARMACRO_KEY_EVENT) or
#_         (Rec.EventType == F.KEY_EVENT and Rec.KeyDown)
#_      then
#_        if Rec.UnicodeChar == "t" then
#_          editor.InsertText("X")
#_          editor.Redraw()
#_          return true
#_        end
#_      end
#_    end
#_
#_    local function ShowTemplatesMenu (Event, Param)
#_      if Event == F.EE_READ then
#_        require 'fl_scripts/editor/template'
#_        templates_menu()
#_      end
#_    end
#_
#_    AddEvent("EditorInput", ReplaceChar)
#_    AddEvent("EditorEvent", ShowTemplatesMenu)
</article>
</node>
<node>
id=59
lv=0
dt=Text
nm=Command line and macro calls
mtime=3851459121
<article>
#_<markdown>
#_
#_###Syntax
#_      lfe: [<options>] <command>|-r<filename> [<arguments>]
#_
#_####Options
#_      -a          asynchronous execution
#_      -e <str>    execute string <str>
#_      -l <lib>    load library <lib>
#_
#_####Command
#_Any command added via [`AddCommand`](57.html) function in
#_*_usermenu.lua*.
#_
#_####Filename
#_Name of a Lua script file. It can be either absolute, or relative
#_to the current directory.
#_
#_####Example of command line call
#_      lfe: calc 2+2
#_
#_####Example of macro call
#_      CallPlugin(0x10000,"-a calc 2+2")
#_
</article>
</node>
<node>
id=78
lv=1
dt=Text
nm=Another syntax
ctime=3851458231
mtime=3851458894
<article>
#_<markdown>
#_
#_###Syntax
#_      lfe: = <expression_list>
#_
#_This syntax allows to display an expression list, e.g.
#_      lfe: = 5, 6+44, "apple"
#_is equivalent to
#_      far.Show(5, 6+44, "apple")
#_
</article>
</node>
<node>
id=31
lv=0
dt=Text
nm=Plugin API
mtime=3852182734
<article>
#_<markdown>
#_
#_1. There is an important thing to know when writing scripts for
#_   *LuaFAR for Editor*: indexing string variables accesses functions
#_   in **`utf8`** rather than in **`string`** namespace.
#_     * For example, `s:sub(1,2)` means `utf8.sub(s,1,2)`.
#_     * To use `string` library, specify that explicitly,
#_       e.g., `string.sub(s,1,2)`.
#_     * **`#s`** refers to `string.len(s)`. Use **`s:len()`**
#_       to obtain number of characters.
#_1. The plugin has a few functions that are available to user scripts.
#_   They are placed under **lf4ed** namespace.
#_     * [`lf4ed.config`](32.html)
#_     * [`lf4ed.reload`](79.html)
#_     * [`lf4ed.version`](33.html)
#_
</article>
</node>
<node>
id=32
lv=1
dt=Text
nm=lf4ed.config
<article>
#_Get or set the plugin configuration.
#_
#_cfg = lf4ed.config ([newcfg])
#_
#_**Parameters:**
#_  *newcfg*:  table
#_           Fields of *newcfg* (every field is optional):
#_             ReloadDefaultScript : boolean
#_             RequireWithReload   : boolean
#_             UseStrict           : boolean
#_             UseSearchMenu       : boolean
#_             ReturnToMainMenu    : boolean
#_
#_**Returns:**
#_  *cfg*:     table (the configuration as it was before the call)
#_
#_**Description:**
#_  If *newcfg* is given, it is a table with configuration
#_  parameters to be set. Parameters not contained in this
#_  table will remain unchanged. This means that
#_  (newcfg.param == false) will set 'param' to false, but
#_  (newcfg.param == nil) will leave 'param' as it was before
#_  the call.
#_  Returned is a copy of the "old" configuration table (as it
#_  was before the call).
#_
#_  If *newcfg* is not given, an up-to-date copy of the
#_  configuration table is returned. This table contains the
#_  same fields as the *newcfg* table described above.
#_
#_**Note:**
#_  Configuration changes done by a user script via this
#_  function are reverted by the plugin after the user script
#_  exits.
#_
#_
</article>
</node>
<node>
id=79
lv=1
dt=Text
nm=lf4ed.reload
ctime=3851704547
mtime=3851705152
<article>
#_Reload user file.
#_
#_lf4ed.reload()
#_
#_**Parameters:**
#_  none
#_
#_**Returns:**
#_  nothing
#_
#_This function reloads file _usermenu.lua.
#_This is the same as running "Reload User File" from the plugin's
#_configuration menu.
#_
</article>
</node>
<node>
id=33
lv=1
dt=Text
nm=lf4ed.version
<article>
#_Get plugin version.
#_
#_version = lf4ed.version()
#_
#_**Parameters:**
#_  none
#_
#_**Returns:**
#_  *version*: string, e.g. "0.8.0"
#_
#_
</article>
</node>
<node>
id=21
lv=0
dt=Text
nm=Lua Modules
<article>
#_<markdown>
#_There are a few Lua modules that can be used in the utilities added by the user:
#_
#_* [`far2.dialog`](22.html)
#_* [`far2.history`](23.html)
#_* [`far2.searchmenu`](24.html)
#_
</article>
</node>
<node>
id=22
lv=1
dt=Text
nm=far2.dialog
<article>
#_<markdown>
#_Module `far2.dialog` makes common operations with FAR dialogs easier. It contains the following functions: [`NewDialog`][1], [`LoadData`][2] and [`SaveData`][3].
#_
#_The module is loaded as follows:<br>
#_`require "far2.dialog"`
#_
#_[1]: 25.html
#_[2]: 26.html
#_[3]: 27.html
#_
#_
#_
</article>
</node>
<node>
id=25
lv=2
dt=Text
nm=NewDialog
mtime=3499357876
<article>
#_dlg = far2_dialog.NewDialog()
#_
#_**Parameters:**
#_  none
#_
#_**Returns:**
#_  dlg: Dialog object (a table).
#_       It represents the full set of dialog items, and is eventually
#_       passed to function *far.Dialog* as its 6-th parameter.
#_
#_**Description:**
#_The dialog object has the following features:
#_
#_1. To add an item, assign it to some string field of the object, e.g.:
#_
#_     dlg.cbxCase = {"DI_CHECKBOX",10,4,0,0,0,0,0,0,"&Case sensitive"}
#_     dlg.cbxWord = {"DI_CHECKBOX",10,5,0,0,0,0,0,0,"&Whole words"}
#_
#_   The added items are now accessible by their names: dlg.cbxCase,
#_   dlg.cbxWord. If there are items that need not to be accessed
#_   after their adding, they can be assigned the same name, e.g.,
#_   dlg.label or dlg._
#_
#_2. The properties of the added items are accessible in two ways:
#_   either by index, or by name.
#_
#_     print(dlg.cbxCase[3]) --> 4
#_     print(dlg.cbxCase.Y1) --> 4
#_     dlg.cbxCase.Y1 = 6
#_     print(dlg.cbxCase[3]) --> 6
#_     print(dlg.cbxCase.Y1) --> 6
#_
#_2.1. Here is the correspondence between indexes and names of dialog
#_   item properties (wherever multiple names are listed for an index,
#_   any of them may be used):
#_
#_      1 : Type
#_      2 : X1
#_      3 : Y1
#_      4 : X2
#_      5 : Y2
#_      6 : Focus
#_      7 : Selected, History, Mask, ListItems, ListPos, VBuf
#_      8 : Flags
#_      9 : DefaultButton
#_     10 : Data, Ptr
#_
#_
</article>
</node>
<node>
id=26
lv=2
dt=Text
nm=LoadData
mtime=3499357885
<article>
#_far2_dialog.LoadData(aDialog, aData)
#_
#_**Parameters:**
#_  aDialog : a dialog object created by a NewDialog call
#_  aData   : a table with data to load into *aDialog*
#_
#_**Returns:**
#_  nothing
#_
#_**Description:**
#_  The function copies input data *aData* into a dialog object *aDialog*.
#_  The dialog items must be added to the object *before* this function
#_  is called, since this function loads data only to existing dialog
#_  items.
#_
#_  - The following item types are supported by the function:
#_    DI_CHECKBOX, DI_RADIOBUTTON, DI_EDIT, DI_FIXEDIT, DI_LISTBOX,
#_    DI_COMBOBOX.
#_  
#_  - The following properties are loaded by the function:
#_     - For DI_CHECKBOX, DI_RADIOBUTTON, DI_LISTBOX, DI_COMBOBOX:
#_       only index 7 ("Selected" or "ListPos").
#_     - For DI_EDIT, DI_FIXEDIT: only index 10 ("Data").
#_
#_  - Data are loaded to items whose names are identical to the names
#_    of the *aData* fields.
#_
#_  - If an item has either of fields *_noautoload* or *_noauto* set to
#_    true, it is not loaded.
#_
#_**Example:**
#_  local dlg = far2.dialog.NewDialog()
#_  dlg.cbxCase = {"DI_CHECKBOX",10,4,0,0,0,0,0,0,"&Case sensitive"}
#_  dlg.cbxWord = {"DI_CHECKBOX",10,5,0,0,0,0,0,0,"&Whole words"}
#_  far2.dialog.LoadData(dlg, {cbxCase=true, cbxWord=false})
#_
#_@@@
#_<lua> Links = { ["NewDialog"]="25.html", } </lua>
#_
#_function LoadData (aDialog, aData)
#_  for _,item in ipairs(aDialog) do
#_    if not item._noautoload then
#_      if CheckItemType(item, "DI_CHECKBOX", "DI_RADIOBUTTON") then
#_        if aData[item.name] == nil then --> nil==no data; false==valid data
#_          item[7] = item[7] or 0
#_        else
#_          item[7] = aData[item.name] and 1 or 0
#_        end
#_      elseif CheckItemType(item, "DI_EDIT", "DI_FIXEDIT") then
#_        item[10] = aData[item.name] or item[10] or ""
#_      elseif CheckItemType(item, "DI_LISTBOX", "DI_COMBOBOX") then
#_        item[7].SelectIndex = aData[item.name] and aData[item.name].SelectIndex or 1
#_      end
#_    end
#_  end
#_end
#_
</article>
</node>
<node>
id=27
lv=2
dt=Text
nm=SaveData
mtime=3499357892
<article>
#_far2_dialog.SaveData(aDialog, aData)
#_
#_**Parameters:**
#_  aDialog : a dialog object created by a NewDialog call
#_  aData   : a table to save data in from *aDialog*
#_
#_**Returns:**
#_  nothing
#_
#_**Description:**
#_  The function copies data from a dialog object *aDialog* to *aData*.
#_
#_  - The following item types are supported by the function:
#_    DI_CHECKBOX, DI_RADIOBUTTON, DI_EDIT, DI_FIXEDIT, DI_LISTBOX,
#_    DI_COMBOBOX.
#_  
#_  - The following properties are saved by the function:
#_     - For DI_CHECKBOX, DI_RADIOBUTTON, DI_LISTBOX, DI_COMBOBOX:
#_       only index 7 ("Selected" or "ListPos").
#_     - For DI_EDIT, DI_FIXEDIT: only index 10 ("Data").
#_
#_  - Data are saved by the names identical to the item names.
#_
#_  - If an item has either of fields *_noautosave* or *_noauto* set to
#_    true, it is not saved.
#_
#_**Example:**
#_  local dlg = far2.dialog.NewDialog()
#_  dlg.cbxCase = {"DI_CHECKBOX",10,4,0,0,0,0,0,0,"&Case sensitive"}
#_  dlg.cbxWord = {"DI_CHECKBOX",10,5,0,0,0,0,0,0,"&Whole words"}
#_  -- add other items
#_  -- call far.Dialog(...)
#_  local data = {}
#_  far2.dialog.SaveData(dlg, data)
#_  return data
#_
#_@@@
#_<lua> Links = { ["NewDialog"]="25.html", } </lua>
#_
#_function SaveData (aDialog, aData)
#_  for _,item in ipairs(aDialog) do
#_    if not item._noautosave then
#_      if CheckItemType(item, "DI_CHECKBOX", "DI_RADIOBUTTON") then
#_        aData[item.name] = (item[7] ~= 0)
#_      elseif CheckItemType(item, "DI_EDIT", "DI_FIXEDIT") then
#_        aData[item.name] = item[10]
#_      elseif CheckItemType(item, "DI_LISTBOX", "DI_COMBOBOX") then
#_        aData[item.name] = aData[item.name] or {}
#_        aData[item.name].SelectIndex = item[7].SelectIndex
#_      end
#_    end
#_  end
#_end
#_
</article>
</node>
<node>
id=24
lv=1
dt=Text
nm=far2.searchmenu
<article>
#_<markdown>
#_###Description
#_
#_This provides a filter for standard menu. Every typed symbol
#_is added to the pattern which is used to check every menu item.
#_Every item which satisfies the pattern is displayed, others become
#_hidden. The pattern is displayed in the menu header.
#_
#_###Parameters
#_    Item, Position = far2.searchmenu(Properties, Items [, BreakKeys])
#_All arguments and return values are the same as for **`far.Menu`**
#_(see LuaFAR manual), except some optional additional fields of
#_`Properties` table:
#_
#_      AllowEmpty:    Allow the user to input patterns that make menu
#_                     empty (boolean)
#_
#_      CheckItem:     Function for determining if an item should be
#_                     displayed:
#_                       from,to = CheckItem(pattern,text[,searchmethod])
#_
#_      Map:           Table that maps keys and key combinations
#_                     to characters and actions. It allows to add
#_                     keys or redefine the treatment of user's input.
#_
#_      Menu:          Function for displaying the menu
#_                     (defaults to far.Menu)
#_
#_      Pattern:       Initial search pattern (string)
#_
#_      SearchMethod:  "lua"   = use Lua regexps (default)
#_                     "dos"   = use DOS wildcards * and ?
#_                     "plain" = plain text search
#_
#_Also, there is an optional field `SearchText` in a menu item. When
#_present, it is used instead of the `text` field when checking the
#_item, while the `text` field is used for displaying the item.
#_
#_###Predefined keys
#_      Space     - insert a space character
#_      DELETE    - delete the entire pattern
#_      BACKSPACE - delete the last symbol
#_      CtrlV     - insert a pattern from the clipboard
#_
#_###Available symbols
#_      Small English letters: a-z
#_      Numbers:  0-9
#_      Symbols: .,><=+-_;:/?`~[]{}()\~|'"!@#$%^&*
#_
#_
</article>
</node>
<node>
id=23
lv=1
dt=Text
nm=history
<article>
#_<markdown>
#_Module `history` saves specified plugin data to files and loads the data from files. The module API consists of the only function [`new`][1] and the 3 methods: [`hobj:field`][2], [`hobj:setfield`][3] and
#_[`hobj:save`][4].
#_
#_The module is loaded as follows:<br>
#_`require "history"`
#_
#_[1]: 28.html
#_[2]: 29.html
#_[3]: 58.html
#_[4]: 30.html
#_
#_
</article>
</node>
<node>
id=28
lv=2
dt=Text
nm=new
mtime=3478521182
<article>
#_hobj = history.new (filename)
#_
#_**Parameters:**
#_  filename : string
#_
#_**Returns:**
#_  hobj     : history object (a table).
#_
#_**Description:**
#_  - The function executes *filename* as a Lua script, in an empty
#_    environment table.
#_
#_  - The script is assumed to contain Lua data in the global
#_    variable *Data* (a table).
#_
#_  - The environment table is returned, with its field *FileName*
#_    set to the value of *filename* argument.
#_
#_  - If the file *filename* was absent or failed to compile, then
#_    the field *Data* of the returned object is an empty table.
#_
#_  - The returned history object *hobj* has three methods:
#_    hobj:field, hobj:setfield and hobj:save.
#_
#_@@@
#_<lua> Links = { ["hobj:field"]="29.html", ["hobj:save"]="30.html", 
#_["hobj:setfield"]="58.html"}
#_</lua>
#_
#_local history = {}
#_local meta = { __index = history }
#_
#_local function load (filename)
#_  local f = loadfile (filename)
#_  if f then
#_    local env = {}
#_    setfenv (f, env)()
#_    return env
#_  end
#_end
#_
#_function new (filename)
#_  local self = load (filename) or { Data = {} }
#_  self.FileName = filename
#_  return setmetatable(self, meta)
#_end
#_
#_
</article>
</node>
<node>
id=29
lv=2
dt=Text
nm=hobj:field
mtime=3478525904
<article>
#_val = hobj:field (name)
#_
#_**Parameters:**
#_  name   : sequence of dot-delimitered fields;
#_
#_**Returns:**
#_  val    : value of the given nested field in history object *hobj*
#_           (will be created if absent).
#_
#_**Description:**
#_  - hobj:field("key1.key2 ... keyN") returns the equivalent of
#_    hobj["key1"]["key2"]...["keyN"].
#_
#_  - If at any stage of retrieving some intermediate nested field
#_    "keyM", its value is nil, then both that and all subsequent
#_    fields are created by assigning each of them a new table.
#_
#_**Example:**
#_
#_  if From == "e" then     hist = _Hist:field ("menu.editor")
#_  elseif From == "v" then hist = _Hist:field ("menu.viewer")
#_  elseif From == "p" then hist = _Hist:field ("menu.pluginsmenu")
#_  else return
#_
#_@@@
#_
</article>
</node>
<node>
id=58
lv=2
dt=Text
nm=hobj:setfield
mtime=3499591303
<article>
#_val = hobj:setfield (name, val)
#_
#_**Parameters:**
#_  name  : sequence of dot-delimitered fields;
#_  val   : value to set the field with
#_
#_**Returns:**
#_  val
#_
#_**Description:**
#_  - hobj:setfield("key1.key2  ... keyN", val) does the equivalent of
#_    hobj["key1"]["key2"]...["keyN"] = val.
#_
#_  - If at any stage of retrieving some intermediate nested field
#_    "keyM", its value is nil, then both that and all subsequent
#_    fields are created by assigning each of them a new table.
#_
#_@@@
#_
</article>
</node>
<node>
id=30
lv=2
dt=Text
nm=hobj:save
<article>
#_hobj:save ()
#_
#_**Parameters:**
#_  none
#_
#_**Returns:**
#_  nothing
#_
#_**Description:**
#_  - The method saves (serializes) the "history object" into
#_    the file whose name was given upon the object creation
#_    (see new function). If the file exists, its contents is
#_    overwritten.
#_
#_  - Only "Data" field of the *hobj* is saved.
#_    - Within it, values of the following types are saved:
#_      numbers, strings, booleans and tables (recursively).
#_    - Not saved: functions, coroutines and userdatas.
#_    - Not saved: metatable relations.
#_
#_@@@
#_<lua> Links = { ["new"]="28.html", }
#_</lua>
#_function history:save()
#_  serial.SaveInFile (self.FileName, "Data", self.Data)
#_end
#_
</article>
</node>
<node>
id=10
lv=0
dt=Text
nm=Credits
mtime=3502994029
<article>
#_<markdown>
#_Many thanks to:
#_
#_* **maxfl** (gmaxfl@gmail.com): ideas, bug reports and the *Searchable Menu* module.
#_* **GalS**: bug reports.
#_* **ccaid**: bug reports.
#_* **Aidar Rakhmatullin**: ideas, translation of the help file into
#_  Russian; bug reports.
#_
</article>
</node>
